---
title: "C++ named requirements: Destructible"
cppdoc:
  revision:
    since: C++11
---

import { DR, DRList } from "@components/defect-report";
import { Desc, DescList } from "@components/desc-list";
import Missing from "@components/Missing.astro";
import { Revision, RevisionBlock } from "@components/revision";

Specifies that an instance of the type can be destructed.


## Requirements
The type `T` satisfies `Destructible` if

Given

- `u`, an expression of type `T`.

- `u`, an lvalue expression of type `Key`.

|Expression| Post-Conditions|
|---|---|
|`u.~T()`| All resources owned by `u` are reclaimed, no exceptions are thrown.|

## Notes


Destructors are called implicitly at the end of object lifetime such as when leaving scope or by the delete-expression. Explicit destructor call as shown in the type requirement table is rare.

Thanks to pseudo destructor call, all scalar types meet the requirement of Destructible, while array types and reference types do not. Note that `std::is_destructible` allows arrays and reference types.

## See also

<DescList>
  <Desc kind="class template">
    <Fragment slot="item">
      <RevisionBlock noborder since="C++11">
        <Missing> `std::is_destructible` </Missing>
      </RevisionBlock>
      <RevisionBlock noborder since="C++11">
        <Missing> `std::is_trivially_destructible` </Missing>
      </RevisionBlock>
      <RevisionBlock noborder since="C++11">
        <Missing> `std::is_nothrow_destructible` </Missing>
      </RevisionBlock>
    </Fragment>
    checks if a type has a non-deleted destructor
  </Desc>
  <Desc kind="concept">
    <Fragment slot="item">
      <RevisionBlock noborder since="C++20">
        <Missing> `destructible` </Missing>
      </RevisionBlock>
    </Fragment>
    specifies that an object of the type can be destroyed
  </Desc>
</DescList>

